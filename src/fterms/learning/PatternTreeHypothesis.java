/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package fterms.learning;

import fterms.FTKBase;
import fterms.FeatureTerm;
import fterms.exceptions.FeatureTermException;
import java.util.HashMap;

/**
 * Notice that Predictions generated by PatternTreeHypothesis do not contain justifications
 *
 * @author santi
 */
public class PatternTreeHypothesis extends Hypothesis {

    public class PatternTreeNode {
        public FeatureTerm m_pattern;
        public PatternTreeNode m_positiveChild,m_negativeChild;
        public HashMap<FeatureTerm,Integer> m_distribution;

        public PatternTreeNode(FeatureTerm pattern) {
            m_pattern = pattern;
            m_positiveChild = null;
            m_negativeChild = null;
            m_distribution = new HashMap<FeatureTerm,Integer>();
        }
    }

    PatternTreeNode m_root = null;

    public Prediction generatePrediction(FeatureTerm problem, FTKBase dm, boolean debug) throws FeatureTermException, Exception {
        PatternTreeNode current = m_root;

        while(current!=null && current.m_pattern!=null) {
            if (current.m_pattern.subsumes(problem)) {
                if (current.m_positiveChild==null) break;
                current = current.m_positiveChild;
            } else {
                if (current.m_negativeChild==null) break;
                current = current.m_negativeChild;
            }
        }

        if (current==null) return null;

        Prediction p = new Prediction();
        p.problem = problem;
        for(FeatureTerm s:current.m_distribution.keySet()) {
            p.solutions.add(s);
            p.support.put(s,current.m_distribution.get(s));
        }
        return p;
    }


    public int size() {
        return sizeInternal(m_root);
    }

    protected int sizeInternal(PatternTreeNode node) {
        int size = 0;
        
        if (node.m_pattern!=null) size+=1;
        if (node.m_positiveChild!=null) size+=sizeInternal(node.m_positiveChild);
        if (node.m_negativeChild!=null) size+=sizeInternal(node.m_negativeChild);
        return size;
    }


    public String toString(FTKBase dm) {
        String tmp = "PatternTreeHypothesis:\n";

        tmp += toStringInternal(dm,m_root,0);

        return tmp;
    }

    protected String toStringInternal(FTKBase dm, PatternTreeNode node, int depth) {
        String tmp = "";
        String indent = "";

        for(int i = 0;i<depth;i++) indent += "  ";
        if (node.m_pattern!=null) {
            tmp += indent + "pattern: \n" + node.m_pattern.toStringNOOS(dm) + "\n";
            tmp += "distribution: [ ";
        } else {
            tmp += indent + "distribution: [ ";
        }
        for(FeatureTerm s:node.m_distribution.keySet()) {
            tmp += s.toStringNOOS(dm) + " - " + node.m_distribution.get(s) + " ";
        }
        tmp += "]";
        tmp = tmp.replaceAll("\n", "\n" + indent );
        tmp += "\n";

        if (node.m_positiveChild!=null) {
            tmp += indent + "positive child:\n";
            tmp += toStringInternal(dm,node.m_positiveChild,depth+1);
        }

        if (node.m_negativeChild!=null) {
            tmp += indent + "negative child:\n";
            tmp += toStringInternal(dm,node.m_negativeChild,depth+1);
        }
        return tmp;
    }
}
